#!/usr/bin/env ruby

require 'optparse'
require 'tag_ripper'
require 'pp'

json = false
debug = false
vim = false
emacs = false
debug_full = false
recurse = false
only_ruby = false
ignore_errors = false

OptionParser.new do |opts|
  opts.banner = "Usage: #{opts.program_name} [options] FILES..."

  opts.version = "0.1.2"

  opts.on("--json", "Output JSON") do |v|
    require 'yajl'
    json = v
  end
  opts.on("--vim", "Output Vim tags format") do |v|
    vim = v
  end
  opts.on("--emacs", "Output Emacs etags format") do |v|
    emacs = v
  end

  opts.on("-R", "--recurse", "Recurse into subdirectories") do |v|
    recurse = v
  end
  opts.on("--only-rb", "Process only .rb files") do |v|
    only_ruby = v
  end

  opts.on("-d", "--debug", "Output debugging info") do |v|
    debug = v
  end
  opts.on("--debug-full", "Output raw SEXP") do |v|
    debug_full = v
  end

  opts.on("--ignore-errors", "Ignore parsing errors") do |v|
    ignore_errors = v
  end

  opts.on_tail("-v", "--version", "Show version") do
    puts opts.version
    exit
  end

  opts.parse!
  abort(opts.banner) if ARGV.empty?
end

trap(:INT) { abort }
trap(:PIPE) { abort }

ARGV.each do |file|
  begin
    if File.directory?(file) and recurse
      Dir.foreach(file){ |f| ARGV << File.expand_path(File.join(file, f)) if f !~ /^\.\.?/ }
      next
    else
      next if only_ruby and file !~ /\.rb$/
      data = File.read(file)
    end
    sexp = TagRipper.new(data, file).parse
    v = TagRipper::Visitor.new(sexp, file, data)

    if debug_full
      pp Ripper.sexp(data)

    elsif debug
      pp sexp

    elsif json
      v.tags.each do |tag|
        puts Yajl.dump(tag)
      end

    elsif emacs
      section = []
      v.tags.each do |tag|
        section << "#{tag[:pattern]}\x7F#{tag[:name]}\x01#{tag[:line]},0"
      end
      section = section.join("\n")

      print "\x0C\n#{file},#{section.bytesize}\n#{section}\n"

    elsif vim
      all_tags += v.tags

    else
      v.tags.each do |tag|
        kind = case tag[:kind]
        when /method$/ then 'def'
        when /^const/  then 'const'
        else tag[:kind]
        end

        if kind == 'class' && tag[:inherits]
          suffix = " < #{tag[:inherits]}"
        else
          suffix = ''
        end

        puts "#{tag[:line].to_s.rjust(5)}  #{kind.to_s.rjust(6)}   #{tag[:full_name]}#{suffix}"
      end
    end
  rescue => e
    unless ignore_errors
      STDERR.puts [e, file].inspect
      raise e
    end
  end
end

if vim
  puts <<-EOC
!_TAG_FILE_FORMAT\t2\t/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED\t1\t/0=unsorted, 1=sorted, 2=foldcase/
EOC

  all_tags.sort_by!{ |t| t[:name] }
  all_tags.each do |tag|
    kwargs = ''
    kwargs << "\tclass:#{tag[:class].gsub('::','.')}" if tag[:class]
    kwargs << "\tinherits:#{tag[:inherits].gsub('::','.')}" if tag[:inherits]

    kind = case tag[:kind]
           when 'method' then 'f'
           when 'singleton method' then 'F'
           when 'constant' then 'C'
           else tag[:kind].slice(0,1)
           end

    code = tag[:pattern].gsub('\\','\\\\\\\\').gsub('/','\\/')
    puts "%s\t%s\t/^%s$/;\"\t%c%s" % [tag[:name], tag[:path], code, kind, kwargs]
  end
end
